var searchInsert = function (nums, target) {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
};

// Intuition: Binary Search / hint is given in context O(log n)

/* 
1. Create two vars, left and right to initialize index position at start and end
2. while left is less than or equal to right, keep searching as long as the range is valid(left hasn't passed right)
3. calculate the middle index of the range using equation: let mid = Math.floor(left+right/2) 
(e.g. 7+0/2= 3.5 -> Math.floor(3.5) = 3) For any given length arr this will calculate the middle index
4. First case: if middle index is target, return middle value
5. Second case: if middle value is less than target(too small) then eliminate the left to mid (inclusive)
6. Third case: if middle value is greater than target(too big) target must be in the left half
7. If target is not acquired then return the left. This is because the loop exits when left > right
So, left is pointing to the first element >= target
So if the target exists -> we already returned it's index
If not, left is exactly where it should be inserted
*/

// Time complexity - O(log n) - Binary search
// Space complexity - O(1) - Only using left, right, mid variables
